// src/taskpane/features/comparison/services/summary.service.ts

import {
  IDiffResult,
  IHighLevelChange,
  ISummaryResult,
  IReportStructuralChange,
  IReportRowChange,
  ICombinedChange,
} from "../../../types/types";

/**
 * A dedicated function to create human-readable descriptions from the high-level
 * structural change events generated by the timeline resolver.
 */
function describeStructuralChanges(structuralChanges: IReportStructuralChange[]): IHighLevelChange[] {
  const highLevelChanges: IHighLevelChange[] = [];

  for (const change of structuralChanges) {
    let description = "";
    // We only want to generate summary descriptions for row/column events here.
    // Sheet events are handled separately or are self-descriptive.
    switch (change.type) {
      case "row_insertion":
        description = change.count! > 1
          ? `Rows ${change.index! + 1}-${change.index! + change.count!} were inserted.`
          : `Row ${change.index! + 1} was inserted.`;
        break;
      case "row_deletion":
        description = change.count! > 1
          ? `Rows ${change.index! + 1}-${change.index! + change.count!} were deleted.`
          : `Row ${change.index! + 1} was deleted.`;
        break;
      // TBD: Add cases for column_insertion / column_deletion if needed.
    }

    if (description) {
      highLevelChanges.push({
        type: "structural",
        sheet: change.sheet,
        description,
        involvedCells: [],
      });
    }
  }

  return highLevelChanges;
}

/**
 * Creates human-readable descriptions for consequential changes, like #REF! errors
 * caused by sheet deletions, by inspecting cell metadata.
 */
function describeConsequentialChanges(modifiedCells: ICombinedChange[]): IHighLevelChange[] {
  const highLevelChanges: IHighLevelChange[] = [];

  for (const change of modifiedCells) {
    if (change.metadata?.isConsequential) {
      let description = "";
      if (change.metadata.reason === 'ref_error_sheet_deleted') {
        // This can be enhanced in the future by parsing the oldFormula to find the exact sheet name.
        // For now, this provides significant value over a simple formula change.
        description = `Cell ${change.address} now shows a #REF! error because a sheet it depended on was deleted.`;
      }

      if (description) {
        highLevelChanges.push({
          type: "structural", // Group with other high-level structural events in the UI.
          sheet: change.sheet,
          description,
          involvedCells: [], // This could be populated with the change itself if the UI needs it.
        });
      }
    }
  }

  return highLevelChanges;
}


/**
 * Associates row data (the actual cell content) with the high-level description
 * of its deletion, allowing the UI to show what was in a row when it was deleted.
 */
function associateDeletedRowData(highLevelChanges: IHighLevelChange[], deletedRows: IReportRowChange[]): void {
    const deletedRowMap = new Map<string, IReportRowChange>();
    // Create a lookup map for faster access: "SheetName!rowIndex" -> IRowChange
    for (const row of deletedRows) {
        deletedRowMap.set(`${row.sheet}!${row.rowIndex}`, row);
    }

    for (const change of highLevelChanges) {
        if (change.description.includes("deleted")) {
            // Re-parse the description to find the rows it refers to.
            // This is simpler than trying to re-engineer the coalescing logic.
            const match = change.description.match(/Row(s?) (\d+)(-(\d+))?/);
            if (match) {
                const startRow = parseInt(match[2], 10) - 1;
                const endRow = match[4] ? parseInt(match[4], 10) - 1 : startRow;
                
                const involvedRows: IReportRowChange[] = [];
                for (let i = startRow; i <= endRow; i++) {
                    const rowData = deletedRowMap.get(`${change.sheet}!${i}`);
                    if (rowData) {
                        involvedRows.push(rowData);
                    }
                }
                change.involvedRows = involvedRows;
            }
        }
    }
}


/**
Transforms a raw, technically-correct diff result into a human-readable summary
for display in the UI.
*/
export function generateSummary(result: IDiffResult): ISummaryResult {

  // 1. Get descriptions from row/column insertions and deletions.
  const structuralSummaries = describeStructuralChanges(result.structuralChanges);

  // 2. Get descriptions for consequential changes (like #REF! errors).
  const consequentialSummaries = describeConsequentialChanges(result.modifiedCells);

  // 3. Combine all high-level changes into a single list.
  const highLevelChanges = [...structuralSummaries, ...consequentialSummaries];
  
  // 4. We then supplement these high-level changes with the actual data of deleted rows.
  // This allows the UI to show "Row 3 was deleted. It contained [25]".
  associateDeletedRowData(highLevelChanges, result.deletedRows);

  return {
    highLevelChanges,
    modifiedCells: result.modifiedCells,
  };
}