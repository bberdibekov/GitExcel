// src/taskpane/features/comparison/services/summary.service.ts

import {
  IDiffResult,
  IHighLevelChange,
  ISummaryResult,
  IReportStructuralChange,
  IReportRowChange,
  ICombinedChange,
} from "../../../types/types";
// --- ADDED: Import the address converter to get column letters from indices ---
import { toA1 } from "../../../shared/lib/address.converter";


/**
 * A dedicated function to create human-readable descriptions from the high-level
 * structural change events generated by the timeline resolver.
 */
function describeStructuralChanges(structuralChanges: IReportStructuralChange[]): IHighLevelChange[] {
  const highLevelChanges: IHighLevelChange[] = [];

  for (const change of structuralChanges) {
    let description = "";
    // We only want to generate summary descriptions for row/column events here.
    // Sheet events are handled separately or are self-descriptive.
    switch (change.type) {
      case "row_insertion":
        description = change.count! > 1
          ? `Rows ${change.index! + 1}-${change.index! + change.count!} were inserted.`
          : `Row ${change.index! + 1} was inserted.`;
        break;
      case "row_deletion":
        description = change.count! > 1
          ? `Rows ${change.index! + 1}-${change.index! + change.count!} were deleted.`
          : `Row ${change.index! + 1} was deleted.`;
        break;
      
      // --- START: ADDED COLUMN DESCRIPTION LOGIC ---
      case "column_insertion":
        {
          const startColLetter = toA1(0, change.index!).replace(/[0-9]/g, '');
          if (change.count! > 1) {
            const endColLetter = toA1(0, change.index! + change.count! - 1).replace(/[0-9]/g, '');
            description = `Columns ${startColLetter}-${endColLetter} were inserted.`;
          } else {
            description = `Column ${startColLetter} was inserted.`;
          }
        }
        break;
      case "column_deletion":
        {
          const startColLetter = toA1(0, change.index!).replace(/[0-9]/g, '');
          if (change.count! > 1) {
            const endColLetter = toA1(0, change.index! + change.count! - 1).replace(/[0-9]/g, '');
            description = `Columns ${startColLetter}-${endColLetter} were deleted.`;
          } else {
            description = `Column ${startColLetter} was deleted.`;
          }
        }
        break;
      // --- END: ADDED COLUMN DESCRIPTION LOGIC ---
    }

    if (description) {
      highLevelChanges.push({
        type: "structural",
        sheet: change.sheet,
        description,
        involvedCells: [],
      });
    }
  }

  return highLevelChanges;
}

/**
 * Creates human-readable descriptions for consequential changes, like #REF! errors
 * caused by sheet deletions, by inspecting cell metadata.
 */
function describeConsequentialChanges(modifiedCells: ICombinedChange[]): IHighLevelChange[] {
  const highLevelChanges: IHighLevelChange[] = [];

  for (const change of modifiedCells) {
    if (change.metadata?.isConsequential) {
      let description = "";
      if (change.metadata.reason === 'ref_error_sheet_deleted') {
        // This can be enhanced in the future by parsing the oldFormula to find the exact sheet name.
        // For now, this provides significant value over a simple formula change.
        description = `Cell ${change.address} now shows a #REF! error because a sheet it depended on was deleted.`;
      }

      if (description) {
        highLevelChanges.push({
          type: "structural", // Group with other high-level structural events in the UI.
          sheet: change.sheet,
          description,
          involvedCells: [], // This could be populated with the change itself if the UI needs it.
        });
      }
    }
  }

  return highLevelChanges;
}


/**
 * Associates row data (the actual cell content) with the high-level description
 * of its deletion, allowing the UI to show what was in a row when it was deleted.
 */
function associateDeletedRowData(highLevelChanges: IHighLevelChange[], deletedRows: IReportRowChange[]): void {
    const deletedRowMap = new Map<string, IReportRowChange>();
    // Create a lookup map for faster access: "SheetName!rowIndex" -> IRowChange
    for (const row of deletedRows) {
        deletedRowMap.set(`${row.sheet}!${row.rowIndex}`, row);
    }

    for (const change of highLevelChanges) {
        if (change.description.includes("deleted")) {
            // Re-parse the description to find the rows it refers to.
            // This is simpler than trying to re-engineer the coalescing logic.
            const match = change.description.match(/Row(s?) (\d+)(-(\d+))?/);
            if (match) {
                const startRow = parseInt(match[2], 10) - 1;
                const endRow = match[4] ? parseInt(match[4], 10) - 1 : startRow;
                
                const involvedRows: IReportRowChange[] = [];
                for (let i = startRow; i <= endRow; i++) {
                    const rowData = deletedRowMap.get(`${change.sheet}!${i}`);
                    if (rowData) {
                        involvedRows.push(rowData);
                    }
                }
                change.involvedRows = involvedRows;
            }
        }
    }
}


/**
Transforms a raw, technically-correct diff result into a human-readable summary
for display in the UI.
*/
export function generateSummary(result: IDiffResult): ISummaryResult {

  // 1. Get descriptions from row/column insertions and deletions.
  const structuralSummaries = describeStructuralChanges(result.structuralChanges);

  // 2. Get descriptions for consequential changes (like #REF! errors).
  const consequentialSummaries = describeConsequentialChanges(result.modifiedCells);

  // 3. Combine all high-level changes into a single list.
  const highLevelChanges = [...structuralSummaries, ...consequentialSummaries];
  
  // 4. We then supplement these high-level changes with the actual data of deleted rows.
  // This allows the UI to show "Row 3 was deleted. It contained [25]".
  associateDeletedRowData(highLevelChanges, result.deletedRows);

  return {
    highLevelChanges,
    modifiedCells: result.modifiedCells,
  };
}

export interface ISummaryStats {
    totalChanges: number;
    valueChanges: number;
    formulaChanges: number;
}

/**
 * Calculates the number of value and formula changes from a diff result.
 * This provides a quantitative summary separate from the descriptive summary.
 * @param result The raw diff result object.
 * @returns An object containing the calculated statistics.
 */
export const calculateSummaryStats = (result: IDiffResult | null): ISummaryStats => {
    if (!result) {
        return { totalChanges: 0, valueChanges: 0, formulaChanges: 0 };
    }

    let valueChanges = 0;
    let formulaChanges = 0;

    result.modifiedCells.forEach(cell => {
        if (cell.changeType === 'value') {
            valueChanges++;
        } else if (cell.changeType === 'formula') {
            formulaChanges++;
        } else if (cell.changeType === 'both') {
            // A 'both' change means the value and formula changed independently.
            // We count it as one of each.
            valueChanges++;
            formulaChanges++;
        }
    });

    return {
        totalChanges: result.modifiedCells.length,
        valueChanges,
        formulaChanges
    };
};