// src/taskpane/services/summary.service.ts

import {
  IDiffResult,
  IHighLevelChange,
  ISummaryResult,
  IReportStructuralChange,
  IReportRowChange,
} from "../../../types/types";

/**
 * A dedicated function to create human-readable descriptions from the high-level
 * structural change events generated by the timeline resolver.
 */
function describeStructuralChanges(structuralChanges: IReportStructuralChange[]): IHighLevelChange[] {
  const highLevelChanges: IHighLevelChange[] = [];

  for (const change of structuralChanges) {
    let description = "";
    // We only want to generate summary descriptions for row/column events here.
    // Sheet events are handled separately or are self-descriptive.
    switch (change.type) {
      case "row_insertion":
        description = change.count! > 1
          ? `Rows ${change.index! + 1}-${change.index! + change.count!} were inserted.`
          : `Row ${change.index! + 1} was inserted.`;
        break;
      case "row_deletion":
        description = change.count! > 1
          ? `Rows ${change.index! + 1}-${change.index! + change.count!} were deleted.`
          : `Row ${change.index! + 1} was deleted.`;
        break;
      // TBD: Add cases for column_insertion / column_deletion if needed.
    }

    if (description) {
      highLevelChanges.push({
        type: "structural",
        sheet: change.sheet,
        description,
        involvedCells: [],
      });
    }
  }

  return highLevelChanges;
}


/**
 * Associates row data (the actual cell content) with the high-level description
 * of its deletion, allowing the UI to show what was in a row when it was deleted.
 */
function associateDeletedRowData(highLevelChanges: IHighLevelChange[], deletedRows: IReportRowChange[]): void {
    const deletedRowMap = new Map<string, IReportRowChange>();
    // Create a lookup map for faster access: "SheetName!rowIndex" -> IRowChange
    for (const row of deletedRows) {
        deletedRowMap.set(`${row.sheet}!${row.rowIndex}`, row);
    }

    for (const change of highLevelChanges) {
        if (change.description.includes("deleted")) {
            // Re-parse the description to find the rows it refers to.
            // This is simpler than trying to re-engineer the coalescing logic.
            const match = change.description.match(/Row(s?) (\d+)(-(\d+))?/);
            if (match) {
                const startRow = parseInt(match[2], 10) - 1;
                const endRow = match[4] ? parseInt(match[4], 10) - 1 : startRow;
                
                const involvedRows: IReportRowChange[] = [];
                for (let i = startRow; i <= endRow; i++) {
                    const rowData = deletedRowMap.get(`${change.sheet}!${i}`);
                    if (rowData) {
                        involvedRows.push(rowData);
                    }
                }
                change.involvedRows = involvedRows;
            }
        }
    }
}


/**
Transforms a raw, technically-correct diff result into a human-readable summary
for display in the UI.
*/
export function generateSummary(result: IDiffResult): ISummaryResult {

  // 1. The primary source for the summary is the high-level structural changes.
  const highLevelChanges = describeStructuralChanges(result.structuralChanges);
  
  // 2. We then supplement these high-level changes with the actual data of deleted rows.
  // This allows the UI to show "Row 3 was deleted. It contained [25]".
  associateDeletedRowData(highLevelChanges, result.deletedRows);


  return {
    highLevelChanges,
    modifiedCells: result.modifiedCells,
  };
}